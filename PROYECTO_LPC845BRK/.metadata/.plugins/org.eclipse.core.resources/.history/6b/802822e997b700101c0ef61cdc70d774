/*
 * max30102.c adaptado a c++.
 * VERSIÓN LIMPIA (SIN FLOATS)
 *
 * Created on: 1 nov 2025
 * Author: guido
 */

#include "Defines.h" // Este ya incluye max30102.h y UART0.h
#include <stdio.h>
#include <string.h>

// --- Objetos y Variables Globales ---
extern UART0 Uart0;
extern volatile uint32_t g_millis; // El reloj de 1ms desde main.cpp

uint8_t data[192], CantDatos;
uint8_t buffer[100];
uint32_t consolidado[32];

volatile uint8_t g_flagLecturaMAX30102 = 0;

// --- Variables para Cálculo de BPM (SOLO ENTEROS) ---
volatile uint16_t g_currentBPM = 0;             // El BPM calculado final
const int32_t BEAT_THRESHOLD_INT = 100;         // Umbral de ruido. ¡Quizás necesites ajustar este valor!
bool g_isBeat = false;                          // Máquina de estados: ¿estamos en un latido?

#define BPM_SAMPLE_COUNT 4                      // Cantidad de latidos para promediar
uint32_t g_beatTimestamps[BPM_SAMPLE_COUNT] = {0}; // Array con los tiempos de los latidos
uint8_t g_beatIndex = 0;                        // Índice del array
// ------------------------------------


/**
 * @brief Reemplazo de DCRemoval usando solo enteros.
 * Es un filtro High-Pass (FIR) simple: y[n] = x[n] - x[n-1]
 * Elimina el DC (constante) y deja solo el AC (cambios).
 * @param raw_value El valor 'red' crudo (uint32_t) leído del sensor.
 * @return El valor filtrado (AC) de 32 bits.
 */
int32_t DCRemoval_int(uint32_t raw_value)
{
    // 'static' hace que esta variable "recuerde" su valor
    // entre cada llamada a la función (es nuestra "memoria" del filtro).
    static int32_t last_raw_value = 0; 
    
    int32_t filtered_value = (int32_t)raw_value - last_raw_value;
    last_raw_value = (int32_t)raw_value; // Guarda el valor actual para la próxima resta

    return filtered_value;
}


void SetFlagLecturaMAX30102( uint8_t valor )
{
	g_flagLecturaMAX30102 = valor;
}

uint8_t GetFlagLecturaMAX30102( void )
{
	return g_flagLecturaMAX30102;
}


void MAX30102( void )
{
	static uint8_t estado = 0;
	uint8_t rd, wr, ov;
	int32_t samples;
	uint32_t red = 0, ir = 0;

	switch( estado )
	{
	case 0:
		//Init
		if( MAX30102InitialConfig() == 0 )
		{
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 1;
		}

		break;

	case 1:
		if( !GetDemora_IIC() )
		{
			wr = MAX30102_Read( MAX30102_FIFO_WR_PTR );
			ov = MAX30102_Read( MAX30102_FIFO_OV_PTR );
			rd = MAX30102_Read( MAX30102_FIFO_RD_PTR );

			samples = rd - wr;
			if( ov >= 0xF )
			{
				ov = 0;
			}
			if(samples < 0)
				samples +=MAX30102_SAMPLE_LEN_MAX;

			if( wr == 0xFF )
				samples = 0;

			//Lectura de toda la FIFO
			MAX30102_Read_FIFO( MAX30102_FIFO_DATA, data, samples, &red, &ir);


			if( samples )
			{
                // --- INICIO: Lógica de Filtro y BPM (SOLO ENTEROS) ---
                
                // 1. Llamamos a la nueva función de filtro (usa enteros)
                int32_t red_filtered = DCRemoval_int(red); // Usa el 'red' crudo

                // 2. Lógica de Detección de BPM (usa el valor filtrado)
                if (red_filtered > BEAT_THRESHOLD_INT) // 1. La señal es alta
                {
                    if (g_isBeat == false) // 2. Es un *nuevo* latido
                    {
                        // --- ¡LATIDO DETECTADO! ---
                        g_isBeat = true; // Flag para no re-contar
                        uint8_t current_index = g_beatIndex % BPM_SAMPLE_COUNT;
                        uint8_t oldest_index = (g_beatIndex + 1) % BPM_SAMPLE_COUNT;
                        g_beatTimestamps[current_index] = g_millis;

                        uint32_t time_delta_ms = g_beatTimestamps[current_index] - g_beatTimestamps[oldest_index];
                        g_beatIndex++; 

                        if (g_beatIndex > BPM_SAMPLE_COUNT && time_delta_ms > 0)
                        {
                            // --- Cálculo de BPM con Enteros ---
                            // BPM = (60000 * (BPM_SAMPLE_COUNT - 1)) / time_delta_ms
                            g_currentBPM = 180000 / time_delta_ms;
                        }
                    }
                }
                else if (red_filtered < -BEAT_THRESHOLD_INT) // 3. La señal es baja
                {
                    g_isBeat = false; // Reseteamos el flag
                }
                // --- FIN: Lógica de BPM ---

                // --- sprintf (SOLO ENTEROS) ---
                // Imprimimos los valores raw y filtrados para ayudarte a ajustar el umbral
                sprintf((char *)buffer, "Raw: %u | Filt: %d | BPM: %d\n",
                        (uint32_t)red, // Valor raw (será grande, ej: 45000)
                        (int32_t)red_filtered, // Valor filtrado (oscilará, ej: -50, 120)
                        g_currentBPM); // BPM
                
                Uart0.Send(buffer, strlen((char *)buffer));

                red = 0;		//Reset values
                ir = 0;		//Reset values
			}

			estado = 2;
		}
		break;
	case 2:
		if( GetFlagLecturaMAX30102( ) )
		{
			SetFlagLecturaMAX30102( 0 );
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 1;
		}
		break;
	case 3:
		break;
	case 4:
		break;
	default:
		break;
	}
}

void MAX30102ResetPointers( void )
{
	MAX30102_Write( MAX30102_FIFO_WR_PTR, 0 );
	MAX30102_Write( MAX30102_FIFO_OV_PTR, 0 );
	MAX30102_Write( MAX30102_FIFO_RD_PTR, 0 );
}

uint8_t MAX30102InitialConfig( void )
{
	static uint8_t estado = 0;


	switch( estado )
	{
	case 0:
		MAX30102_Write( MAX30102_MODE_CONFIG, 0x40);		//Reset
		SetDemora_IIC(IIC_DELAY_30ms);
		estado = 1;
		break;

	case 1:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_INT_EN_1, 0x00);		//
			MAX30102_Write( MAX30102_INT_EN_2, 0x00);		//
			MAX30102ResetPointers( );
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 2;
		}
		break;

	case 2:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_MODE_CONFIG, 0x03);		//SpO2 Red and IR
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 3;
		}
		break;


	case 3:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_SPO2_CONFIG, 0x40);		//ADC resolution 15 bits, 50 samples per second
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 4;
		}
		break;

	case 4:
		if( !GetDemora_IIC() )
			{
				MAX30102_Write( MAX30102_LED1_PA, MAX30102_LED_PA_7_6mA);		//
				SetDemora_IIC(IIC_DELAY_ms);
				estado = 5;
			}
			break;



	case 5:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_LED2_PA, MAX30102_LED_PA_7_6mA);		//
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 6;
		}
		break;

	case 6:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_FIFO_CONFIG, 0x00);		//
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 7;
		}
		break;

	case 7:
		estado = 0;
		break;


	default:
		estado = 0;
		break;


	}

	return estado;
}

void MAX30102_Write( uint8_t reg, uint8_t value )
{
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Write(value);
	IIC_Stop();
}

uint8_t MAX30102_Read( uint8_t reg )
{
	uint8_t value;

	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	value = IIC_Read(NO_ACK);
	IIC_Stop();
	return value;
}

void MAX30102_Read_Sample( uint8_t reg, uint8_t * buff)
{
	uint8_t i;
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	for(i = 0; i < 6; i ++ )	//cada muestra es de 6 bytes
	{
		buff[i] = IIC_Read(ACK);
	}

	IIC_Stop();
}

void MAX30102_Read_FIFO( uint8_t reg, uint8_t * buff, uint8_t samples, uint32_t * red, uint32_t * ir)
{
	uint8_t i;
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	if( samples )
	{	for(i = 0; i < samples*MAX30102_BYTES_PER_SAMPLE; i ++ )	//cada muestra es de 6 bytes
		{
			buff[i] = IIC_Read(ACK);
		}

	}
	else
	{
		for(i = 0; i < 6; i ++ )	//cada muestra es de 6 bytes
		{
			buff[i] = IIC_Read(ACK);
		}

	}
	IIC_Stop();

	if( samples )
	{
		for(i = 0; i < samples; i ++ )
		{
			*red += (buff[(i*MAX30102_BYTES_PER_SAMPLE)]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+1]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+2];
			*ir += (buff[(i*MAX30102_BYTES_PER_SAMPLE)+3]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+4]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+5];
		}
	}
	else
	{
		*red = (data[0]<<16) | (data[1]<<8) | data[2];      // Last IR reflectance datapoint
		*ir = (data[3]<<16) | (data[4]<<8) | data[5];     // Last Red reflectance datapoint
		*red &= 0x03FFFF;
		*ir &= 0x03FFFF;
	}

	if( samples )
	{
		*red /= samples;
		*ir /= samples;
		*red &= 0x03FFFF;
		*ir &= 0x03FFFF;
	}

	// --- LÍNEAS DE FLOAT BORRADAS ---
	// Ya no llamamos a DCRemoval con floats aquí.
	// El filtrado se hace en MAX30102() con enteros.
}
