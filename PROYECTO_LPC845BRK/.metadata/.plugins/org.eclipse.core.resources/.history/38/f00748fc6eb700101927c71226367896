/*
 * max30102.c
 *
 *  Created on: 1 nov 2025
 *      Author: guido
 */


#include "max30102.h"
#include "UART0.h"
#include <stdio.h>
#include <string.h>
#include <stdint.h>
uint8_t data[192], CantDatos;
uint8_t buffer[100];
uint32_t consolidado[32];

float		Ir = 0, Red = 0;
float		Ir_Ant = 0, Red_Ant = 0;

void MAX30102( void )
{
	static uint8_t estado = 0;
	uint8_t rd, wr, ov, status1, status2;
	int32_t samples;
	uint32_t red = 0, ir = 0;

	switch( estado )
	{
	case 0:
		//Init
		if( MAX30102InitialConfig() == 0 )
		{
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 1;
		}

		break;

	case 1:
		if( !GetDemora_IIC() )
		{

			status1 = MAX30102_Read( MAX30102_INT_STATUS_1 );
			status2 = MAX30102_Read( MAX30102_INT_STATUS_2 );
			wr = MAX30102_Read( MAX30102_FIFO_WR_PTR );
			ov = MAX30102_Read( MAX30102_FIFO_OV_PTR );
			rd = MAX30102_Read( MAX30102_FIFO_RD_PTR );

			samples = rd - wr;
			if( ov >= 0xF )
			{
				ov = 0;
			}
			if(samples < 0)
				samples +=MAX30102_SAMPLE_LEN_MAX;

			if( wr == 0xFF )
				samples = 0;

			//Lectura de toda la FIFO
			MAX30102_Read_FIFO( MAX30102_FIFO_DATA, data, samples, &red, &ir);

			//Lectura macaca
			//MAX30102_Read_Sample( MAX30102_FIFO_DATA, data);	//En data queda la muestra de los dos canales

			if( samples )
			{
				//sprintf((char *)buffer, "RED: %d - IR: %d wr=%d rd=%d ov=%d st1=%d st2=%d\n", red, ir, wr, rd, ov, status1, status2);
				//sprintf((char *)buffer, "RED: %d - IR: %d\n", red, ir);
				sprintf((char *)buffer, "Red: %.2f - Ir: %.2f\n", Red, Ir);
				UART1_Send(buffer, strlen((char *)buffer));
				//for(int i = 0; i < CantDatos; i++)
				//	UART1_PushTx(data[i]);
				red = 0;		//Reset values
				ir = 0;		//Reset values
			}




			estado = 2;
		}
		break;
	case 2:
		if( GetFlagLecturaMAX30102( ) )
		{
			SetFlagLecturaMAX30102( 0 );
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 1;
		}
		break;
	case 3:

		break;
	case 4:

		break;
	default:
		break;
	}
}

void MAX30102ResetPointers( void )
{
	MAX30102_Write( MAX30102_FIFO_WR_PTR, 0 );
	MAX30102_Write( MAX30102_FIFO_OV_PTR, 0 );
	MAX30102_Write( MAX30102_FIFO_RD_PTR, 0 );
}

uint8_t MAX30102InitialConfig( void )
{
	static uint8_t estado = 0;


	switch( estado )
	{
	case 0:
		MAX30102_Write( MAX30102_MODE_CONFIG, 0x40);		//Reset
		SetDemora_IIC(IIC_DELAY_30ms);
		estado = 1;
		break;

	case 1:
		if( !GetDemora_IIC() )
		{

			//MAX30102_Write( MAX30102_INT_EN_1, 0x80);		//Almost full enable
			MAX30102_Write( MAX30102_INT_EN_1, 0x00);		//
			MAX30102_Write( MAX30102_INT_EN_2, 0x00);		//
			MAX30102ResetPointers( );
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 2;
		}
		break;

	case 2:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_MODE_CONFIG, 0x03);		//SpO2 Red and IR
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 3;
		}
		break;


	case 3:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_SPO2_CONFIG, 0x40);		//ADC resolution 15 bits, 50 samples per second, pulse 69us, fullscale 8192
			//MAX30102_Write( MAX30102_SPO2_CONFIG, 0x07);		//ADC resolution 18 bits, 100 samples per second, pulse 411us, fullscale 2048
			//MAX30102_Write( MAX30102_SPO2_CONFIG, 0x0F);		//ADC resolution 18 bits, 400 samples per second, pulse 411us
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 4;
		}
		break;

	case 4:
		if( !GetDemora_IIC() )
			{
				MAX30102_Write( MAX30102_LED1_PA, MAX30102_LED_PA_7_6mA);		//
				SetDemora_IIC(IIC_DELAY_ms);
				estado = 5;
			}
			break;



	case 5:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_LED2_PA, MAX30102_LED_PA_7_6mA);		//
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 6;
		}
		break;

	case 6:
		if( !GetDemora_IIC() )
		{
			//MAX30102_Write( MAX30102_FIFO_CONFIG, 0xE0);		//32 muestras promedio, rollover on
			MAX30102_Write( MAX30102_FIFO_CONFIG, 0x00);		//
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 7;
		}
		break;

	case 7:
		estado = 0;
		break;


	default:
		estado = 0;
		break;


	}

	return estado;
}

void MAX30102_Write( uint8_t reg, uint8_t value )
{
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Write(value);
	IIC_Stop();
}

uint8_t MAX30102_Read( uint8_t reg )
{
	uint8_t value;

	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	value = IIC_Read(NO_ACK);
	IIC_Stop();
	return value;
}

void MAX30102_Read_Sample( uint8_t reg, uint8_t * buff)
{
	uint8_t i;
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	for(i = 0; i < 6; i ++ )	//cada muestra es de 6 bytes
	{
		buff[i] = IIC_Read(ACK);
	}

	IIC_Stop();
}

void MAX30102_Read_FIFO( uint8_t reg, uint8_t * buff, uint8_t samples, uint32_t * red, uint32_t * ir)
{
	uint8_t i;
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	if( samples )
	{	for(i = 0; i < samples*MAX30102_BYTES_PER_SAMPLE; i ++ )	//cada muestra es de 6 bytes
		{
			buff[i] = IIC_Read(ACK);
		}

	}
	else
	{
		for(i = 0; i < 6; i ++ )	//cada muestra es de 6 bytes
		{
			buff[i] = IIC_Read(ACK);
		}

	}
	IIC_Stop();

	if( samples )
	{
		for(i = 0; i < samples; i ++ )
		{
			//consolidado[i] 	 = (buff[(i*MAX30102_BYTES_PER_SAMPLE)]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+1]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+2];
			//consolidado[i+1] = (buff[(i*MAX30102_BYTES_PER_SAMPLE)+3]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+4]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+5];

			//*red += consolidado[i];
			//*ir += consolidado[i+1];
			*red += (buff[(i*MAX30102_BYTES_PER_SAMPLE)]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+1]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+2];
			*ir += (buff[(i*MAX30102_BYTES_PER_SAMPLE)+3]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+4]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+5];
		}
	}
	else
	{
		*red = (data[0]<<16) | (data[1]<<8) | data[2];      // Last IR reflectance datapoint
		*ir = (data[3]<<16) | (data[4]<<8) | data[5];     // Last Red reflectance datapoint
		*red &= 0x03FFFF;
		*ir &= 0x03FFFF;
	}

	if( samples )
	{
		*red /= samples;
		*ir /= samples;
		*red &= 0x03FFFF;
		*ir &= 0x03FFFF;
	}

	Ir = DCRemoval((float)(*ir), &Ir_Ant, DC_REMOVER_ALPHA);
	Red = DCRemoval((float)(*red), &Red_Ant, DC_REMOVER_ALPHA);
	CantDatos = samples*MAX30102_BYTES_PER_SAMPLE;
}


float DCRemoval(float x, float *w, float alpha)
{
	float Temporal = x + alpha * (*w);

	float Temporal2 = Temporal - (*w);

	*w = Temporal;

	return Temporal2;
}


