/*
 * max30102.c adaptado a c++.
 *
 *  Created on: 1 nov 2025
 *      Author: guido
 */


#include "Defines.h"
//include "max30102.h"
//include "UART0.h"
#include <stdio.h>
#include <string.h>
//#include <stdint.h>

extern UART0 Uart0;
uint8_t data[192], CantDatos;
uint8_t buffer[100];
uint32_t consolidado[32];

//float		Ir = 0, Red = 0;
//float		Ir_Ant = 0, Red_Ant = 0;

volatile uint8_t g_flagLecturaMAX30102 = 0;

extern volatile uint32_t g_millis;

//----------------------------------
// --- Variables para Cálculo de BPM ---
volatile uint16_t g_currentBPM = 0;   // El BPM calculado final
//const float BEAT_THRESHOLD = 20.0;    // Umbral de ruido. Ajusta este valor si no detecta bien.
bool g_isBeat = false;                // Máquina de estados: ¿estamos en un latido?

#define BPM_SAMPLE_COUNT 4            // Cantidad de latidos para promediar
uint32_t g_beatTimestamps[BPM_SAMPLE_COUNT] = {0}; // Array con los tiempos de los latidos
uint8_t g_beatIndex = 0;              // Índice del array
//----------------------------------

void SetFlagLecturaMAX30102( uint8_t valor )
{
	g_flagLecturaMAX30102 = valor;
}

uint8_t GetFlagLecturaMAX30102( void )
{
	return g_flagLecturaMAX30102;
}

void MAX30102( void )
{
	static uint8_t estado = 0;
	uint8_t rd, wr, ov;			//, status1, status2;
	int32_t samples;
	uint32_t red = 0, ir = 0;

	switch( estado )
	{
	case 0:
		//Init
		if( MAX30102InitialConfig() == 0 )
		{
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 1;
		}

		break;

	case 1:
		if( !GetDemora_IIC() )
		{

			//status1 = MAX30102_Read( MAX30102_INT_STATUS_1 );
			//status2 = MAX30102_Read( MAX30102_INT_STATUS_2 );
			wr = MAX30102_Read( MAX30102_FIFO_WR_PTR );
			ov = MAX30102_Read( MAX30102_FIFO_OV_PTR );
			rd = MAX30102_Read( MAX30102_FIFO_RD_PTR );

			samples = rd - wr;
			if( ov >= 0xF )
			{
				ov = 0;
			}
			if(samples < 0)
				samples +=MAX30102_SAMPLE_LEN_MAX;

			if( wr == 0xFF )
				samples = 0;

			//Lectura de toda la FIFO
			MAX30102_Read_FIFO( MAX30102_FIFO_DATA, data, samples, &red, &ir);

			//Lectura macaca
			//MAX30102_Read_Sample( MAX30102_FIFO_DATA, data);	//En data queda la muestra de los dos canales

			if( samples )
			{
//				//sprintf((char *)buffer, "RED: %d - IR: %d wr=%d rd=%d ov=%d st1=%d st2=%d\n", red, ir, wr, rd, ov, status1, status2);
//				//sprintf((char *)buffer, "RED: %d - IR: %d\n", red, ir);
//				sprintf((char *)buffer, "Red: %.2f - Ir: %.2f\n", Red, Ir);
//				Uart0.Send(buffer, strlen((char *)buffer));
//				//for(int i = 0; i < CantDatos; i++)
//				//	UART1_PushTx(data[i]);
//				red = 0;	//Reset values
//				ir = 0;		//Reset values

				//____________________________________________
				if( samples )
				{
				    // --- INICIO: Lógica de Detección de BPM ---
				    // (La variable 'Red' ya fue actualizada por la función DCRemoval)

				    if (Red > BEAT_THRESHOLD) // 1. La señal es alta (cruzó el umbral)
				    {
				        if (g_isBeat == false) // 2. Es un *nuevo* latido
				        {
				            // --- ¡LATIDO DETECTADO! ---
				            g_isBeat = true; // Ponemos el flag para no volver a contar este pico

				            // Almacenamos el tiempo exacto (en ms) de este latido
				            uint8_t current_index = g_beatIndex % BPM_SAMPLE_COUNT;
				            uint8_t oldest_index = (g_beatIndex + 1) % BPM_SAMPLE_COUNT;

				            g_beatTimestamps[current_index] = g_millis;

				            // Calculamos el tiempo que tomaron los últimos (COUNT-1) latidos
				            uint32_t time_delta_ms = g_beatTimestamps[current_index] - g_beatTimestamps[oldest_index];

				            g_beatIndex++; // Avanzamos el índice para el próximo latido

				            // Esperamos a que el buffer se llene las primeras veces
				            if (g_beatIndex > BPM_SAMPLE_COUNT && time_delta_ms > 0)
				            {
				                // Calculamos el tiempo promedio por latido
				                float avg_beat_time_ms = (float)time_delta_ms / (float)(BPM_SAMPLE_COUNT - 1);

				                // Convertimos a BPM
				                g_currentBPM = (uint16_t)(60000.0f / avg_beat_time_ms);
				            }
				        }
				    }
				    else if (Red < -BEAT_THRESHOLD) // 3. La señal es baja (el "valle")
				    {
				        g_isBeat = false; // Reseteamos el flag, listos para el próximo pico
				    }
				    // --- FIN: Lógica de Detección de BPM ---


				    // --- Modificamos el sprintf para mostrar el BPM ---
				    // (Usamos la versión de enteros para no gastar memoria Flash)

				    int32_t red_entero = (int32_t)Red;
				    int32_t red_decimal = (int32_t)((Red - red_entero) * 100);
				    if (red_decimal < 0) red_decimal *= -1; // Maneja decimales negativos

				    int32_t ir_entero = (int32_t)Ir;
				    int32_t ir_decimal = (int32_t)((Ir - ir_entero) * 100);
				    if (ir_decimal < 0) ir_decimal *= -1; // Maneja decimales negativos

				    // Imprimimos todo en una línea
				    sprintf((char *)buffer, "Red: %d.%02d | Ir: %d.%02d | BPM: %d\n",
				            red_entero, red_decimal,
				            ir_entero, ir_decimal,
				            g_currentBPM); // <-- Mostramos el BPM

				    Uart0.Send(buffer, strlen((char *)buffer));

				    red = 0;		//Reset values
				    ir = 0;		//Reset values
				}
				//____________________________________________


			}

			estado = 2;
		}
		break;
	case 2:
		if( GetFlagLecturaMAX30102( ) )
		{
			SetFlagLecturaMAX30102( 0 );
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 1;
		}
		break;
	case 3:

		break;
	case 4:

		break;
	default:
		break;
	}
}

void MAX30102ResetPointers( void )
{
	MAX30102_Write( MAX30102_FIFO_WR_PTR, 0 );
	MAX30102_Write( MAX30102_FIFO_OV_PTR, 0 );
	MAX30102_Write( MAX30102_FIFO_RD_PTR, 0 );
}

uint8_t MAX30102InitialConfig( void )
{
	static uint8_t estado = 0;


	switch( estado )
	{
	case 0:
		MAX30102_Write( MAX30102_MODE_CONFIG, 0x40);		//Reset
		SetDemora_IIC(IIC_DELAY_30ms);
		estado = 1;
		break;

	case 1:
		if( !GetDemora_IIC() )
		{

			//MAX30102_Write( MAX30102_INT_EN_1, 0x80);		//Almost full enable
			MAX30102_Write( MAX30102_INT_EN_1, 0x00);		//
			MAX30102_Write( MAX30102_INT_EN_2, 0x00);		//
			MAX30102ResetPointers( );
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 2;
		}
		break;

	case 2:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_MODE_CONFIG, 0x03);		//SpO2 Red and IR
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 3;
		}
		break;


	case 3:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_SPO2_CONFIG, 0x40);		//ADC resolution 15 bits, 50 samples per second, pulse 69us, fullscale 8192
			//MAX30102_Write( MAX30102_SPO2_CONFIG, 0x07);		//ADC resolution 18 bits, 100 samples per second, pulse 411us, fullscale 2048
			//MAX30102_Write( MAX30102_SPO2_CONFIG, 0x0F);		//ADC resolution 18 bits, 400 samples per second, pulse 411us
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 4;
		}
		break;

	case 4:
		if( !GetDemora_IIC() )
			{
				MAX30102_Write( MAX30102_LED1_PA, MAX30102_LED_PA_7_6mA);		//
				SetDemora_IIC(IIC_DELAY_ms);
				estado = 5;
			}
			break;



	case 5:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_LED2_PA, MAX30102_LED_PA_7_6mA);		//
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 6;
		}
		break;

	case 6:
		if( !GetDemora_IIC() )
		{
			//MAX30102_Write( MAX30102_FIFO_CONFIG, 0xE0);		//32 muestras promedio, rollover on
			MAX30102_Write( MAX30102_FIFO_CONFIG, 0x00);		//
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 7;
		}
		break;

	case 7:
		estado = 0;
		break;


	default:
		estado = 0;
		break;


	}

	return estado;
}

void MAX30102_Write( uint8_t reg, uint8_t value )
{
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Write(value);
	IIC_Stop();
}

uint8_t MAX30102_Read( uint8_t reg )
{
	uint8_t value;

	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	value = IIC_Read(NO_ACK);
	IIC_Stop();
	return value;
}

void MAX30102_Read_Sample( uint8_t reg, uint8_t * buff)
{
	uint8_t i;
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	for(i = 0; i < 6; i ++ )	//cada muestra es de 6 bytes
	{
		buff[i] = IIC_Read(ACK);
	}

	IIC_Stop();
}

void MAX30102_Read_FIFO( uint8_t reg, uint8_t * buff, uint8_t samples, uint32_t * red, uint32_t * ir)
{
	uint8_t i;
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	if( samples )
	{	for(i = 0; i < samples*MAX30102_BYTES_PER_SAMPLE; i ++ )	//cada muestra es de 6 bytes
		{
			buff[i] = IIC_Read(ACK);
		}

	}
	else
	{
		for(i = 0; i < 6; i ++ )	//cada muestra es de 6 bytes
		{
			buff[i] = IIC_Read(ACK);
		}

	}
	IIC_Stop();

	if( samples )
	{
		for(i = 0; i < samples; i ++ )
		{
			//consolidado[i] 	 = (buff[(i*MAX30102_BYTES_PER_SAMPLE)]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+1]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+2];
			//consolidado[i+1] = (buff[(i*MAX30102_BYTES_PER_SAMPLE)+3]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+4]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+5];

			//*red += consolidado[i];
			//*ir += consolidado[i+1];
			*red += (buff[(i*MAX30102_BYTES_PER_SAMPLE)]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+1]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+2];
			*ir += (buff[(i*MAX30102_BYTES_PER_SAMPLE)+3]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+4]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+5];
		}
	}
	else
	{
		*red = (data[0]<<16) | (data[1]<<8) | data[2];      // Last IR reflectance datapoint
		*ir = (data[3]<<16) | (data[4]<<8) | data[5];     // Last Red reflectance datapoint
		*red &= 0x03FFFF;
		*ir &= 0x03FFFF;
	}

	if( samples )
	{
		*red /= samples;
		*ir /= samples;
		*red &= 0x03FFFF;
		*ir &= 0x03FFFF;
	}

	Ir = DCRemoval((float)(*ir), &Ir_Ant, DC_REMOVER_ALPHA);
	Red = DCRemoval((float)(*red), &Red_Ant, DC_REMOVER_ALPHA);
	CantDatos = samples*MAX30102_BYTES_PER_SAMPLE;
}


float DCRemoval(float x, float *w, float alpha)
{
	float Temporal = x + alpha * (*w);

	float Temporal2 = Temporal - (*w);

	*w = Temporal;

	return Temporal2;
}


