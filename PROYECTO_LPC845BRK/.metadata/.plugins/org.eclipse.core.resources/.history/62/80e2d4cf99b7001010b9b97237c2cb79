/*
 * max30102.c adaptado a c++.
 * VERSIÓN FINAL (SIN FLOATS, CON FILTRO IIR DE ENTEROS)
 *
 * Created on: 1 nov 2025
 * Author: guido
 */

#include "Defines.h" // Este ya incluye max30102.h y UART0.h
#include <stdio.h>
#include <string.h>

// --- Objetos y Variables Globales ---
extern UART0 Uart0;
extern volatile uint32_t g_millis; // El reloj de 1ms desde main.cpp

uint8_t data[192], CantDatos;
uint8_t buffer[100];
uint32_t consolidado[32];

volatile uint8_t g_flagLecturaMAX30102 = 0;

// --- Variables para Cálculo de BPM (SOLO ENTEROS) ---
volatile uint16_t g_currentBPM = 0;             // El BPM calculado final
const int32_t BEAT_THRESHOLD_INT = 100;         // Umbral de ruido. Ajusta este valor si es necesario.
bool g_isBeat = false;                          // Máquina de estados: ¿estamos en un latido?

#define BPM_SAMPLE_COUNT 4                      // Cantidad de latidos para promediar
uint32_t g_beatTimestamps[BPM_SAMPLE_COUNT] = {0}; // Array con los tiempos de los latidos
uint8_t g_beatIndex = 0;                        // Índice del array
// ------------------------------------

// --- Memoria para el filtro (versión enteros) ---
static int32_t w_red = 0; // 'w' es la "memoria" del filtro IIR
const int32_t ALPHA_INT = 95; // Representa alpha = 0.95 (multiplicado por 100)


/**
 * @brief Filtro DCRemoval original, reimplementado con matemática de enteros.
 * Esto es un filtro IIR (Inf. Impulse Response) que aísla el AC (pulso).
 *
 * @param x El valor 'red' crudo (int32_t) leído del sensor.
 * @param w_old Puntero a la "memoria" (w[n-1]) del filtro.
 * @return El valor filtrado (AC) de 32 bits.
 */
static int32_t DCRemoval_int_IIR(int32_t x, int32_t *w_old)
{
    // 1. w[n] = x[n] + (alpha * w[n-1])
    // Usamos (alpha * w[n-1] / 100) para simular 0.95
    int32_t w_new = x + (ALPHA_INT * (*w_old)) / 100;

    // 2. y[n] = w[n] - w[n-1]
    int32_t y = w_new - (*w_old);

    // 3. Guardamos la memoria para la próxima iteración
    *w_old = w_new;

    return y;
}


void SetFlagLecturaMAX30102( uint8_t valor )
{
	g_flagLecturaMAX30102 = valor;
}

uint8_t GetFlagLecturaMAX30102( void )
{
	return g_flagLecturaMAX30102;
}


void MAX30102( void )
{
	static uint8_t estado = 0;
	uint8_t rd, wr, ov;
	int32_t samples;
    
    // Un 'throttle' para no inundar la UART con 50 mensajes por segundo
    static uint32_t last_print_time = 0;

	switch( estado )
	{
	case 0:
		//Init
		if( MAX30102InitialConfig() == 0 )
		{
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 1;
		}
		break;

	case 1:
		if( !GetDemora_IIC() )
		{
			wr = MAX30102_Read( MAX30102_FIFO_WR_PTR );
			ov = MAX30102_Read( MAX30102_FIFO_OV_PTR );
			rd = MAX30102_Read( MAX30102_FIFO_RD_PTR );

			samples = rd - wr;
			if( ov >= 0xF )
			{
				ov = 0;
			}
			if(samples < 0)
				samples +=MAX30102_SAMPLE_LEN_MAX;

			if( wr == 0xFF )
				samples = 0;

            // --- INICIO DE LA LÓGICA CORREGIDA ---
            
            // 1. Leemos todos los bytes de la FIFO (sin promediar)
            uint32_t red_avg_dummy = 0, ir_avg_dummy = 0;
			MAX30102_Read_FIFO( MAX30102_FIFO_DATA, data, samples, &red_avg_dummy, &ir_avg_dummy);

            // Variables para guardar el último valor (para imprimir)
            int32_t latest_filtered_red = 0;
            uint32_t latest_raw_red = 0;

			// 2. Si hay muestras, iteramos sobre CADA UNA
			if( samples > 0 )
			{
                for (int i = 0; i < samples; i++)
                {
                    // a. Reconstruimos la muestra 'red' actual del buffer 'data'
                    uint32_t current_red_raw = (data[(i*MAX30102_BYTES_PER_SAMPLE)]   << 16) | 
                                               (data[(i*MAX30102_BYTES_PER_SAMPLE)+1] << 8)  | 
                                                data[(i*MAX30102_BYTES_PER_SAMPLE)+2];
                    current_red_raw &= 0x03FFFF; // Aplicamos máscara (sensor de 18 bits)
                    
                    // b. Aplicamos el filtro IIR de enteros
                    //    Usamos w_red (la memoria estática)
                    latest_raw_red = current_red_raw; // Guardar para el log
                    latest_filtered_red = DCRemoval_int_IIR((int32_t)current_red_raw, &w_red);

                    // c. Ejecutamos la lógica de detección de BPM en CADA muestra
                    if (latest_filtered_red > BEAT_THRESHOLD_INT) // 1. La señal es alta
                    {
                        if (g_isBeat == false) // 2. Es un *nuevo* latido
                        {
                            g_isBeat = true; // Flag
                            uint8_t current_index = g_beatIndex % BPM_SAMPLE_COUNT;
                            uint8_t oldest_index = (g_beatIndex + 1) % BPM_SAMPLE_COUNT;
                            g_beatTimestamps[current_index] = g_millis;

                            uint32_t time_delta_ms = g_beatTimestamps[current_index] - g_beatTimestamps[oldest_index];
                            g_beatIndex++; 

                            if (g_beatIndex > BPM_SAMPLE_COUNT && time_delta_ms > 0)
                            {
                                g_currentBPM = 180000 / time_delta_ms;
                            }
                        }
                    }
                    else if (latest_filtered_red < -BEAT_THRESHOLD_INT) // 3. La señal es baja
                    {
                        g_isBeat = false; // Reseteamos el flag
                    }
                } // --- Fin del bucle for(samples) ---

                // 3. Imprimimos el resultado (pero solo 4 veces por segundo)
                if (g_millis - last_print_time >= 250)
                {
                    last_print_time = g_millis;
                    
                    // Usamos los *últimos* valores guardados del bucle
                    // ¡YA NO SE RECALCULA EL FILTRO AQUÍ!
                    sprintf((char *)buffer, "Raw: %u | Filt: %d | BPM: %d\n", 
                            (uint32_t)latest_raw_red, 
                            (int32_t)latest_filtered_red, 
                            g_currentBPM);
                    
                    Uart0.Send(buffer, strlen((char *)buffer));
                }
			}
            // --- FIN DE LA LÓGICA CORREGIDA ---

			estado = 2;
		}
		break;
	case 2:
		if( GetFlagLecturaMAX30102( ) )
		{
			SetFlagLecturaMAX30102( 0 );
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 1;
		}
		break;
	default:
		break;
	}
}

void MAX30102ResetPointers( void )
{
	MAX30102_Write( MAX30102_FIFO_WR_PTR, 0 );
	MAX30102_Write( MAX30102_FIFO_OV_PTR, 0 );
	MAX30102_Write( MAX30102_FIFO_RD_PTR, 0 );
}

uint8_t MAX30102InitialConfig( void )
{
	static uint8_t estado = 0;


	switch( estado )
	{
	case 0:
		MAX30102_Write( MAX30102_MODE_CONFIG, 0x40);		//Reset
		SetDemora_IIC(IIC_DELAY_30ms);
		estado = 1;
		break;

	case 1:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_INT_EN_1, 0x00);		//
			MAX30102_Write( MAX30102_INT_EN_2, 0x00);		//
			MAX30102ResetPointers( );
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 2;
		}
		break;

	case 2:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_MODE_CONFIG, 0x03);		//SpO2 Red and IR
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 3;
		}
		break;


	case 3:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_SPO2_CONFIG, 0x40);		//ADC resolution 15 bits, 50 samples per second
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 4;
		}
		break;

	case 4:
		if( !GetDemora_IIC() )
			{
				MAX30102_Write( MAX30102_LED1_PA, MAX30102_LED_PA_7_6mA);		//
				SetDemora_IIC(IIC_DELAY_ms);
				estado = 5;
			}
			break;



	case 5:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_LED2_PA, MAX30102_LED_PA_7_6mA);		//
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 6;
		}
		break;

	case 6:
		if( !GetDemora_IIC() )
		{
			MAX30102_Write( MAX30102_FIFO_CONFIG, 0x00);		//
			SetDemora_IIC(IIC_DELAY_ms);
			estado = 7;
		}
		break;

	case 7:
		estado = 0;
		break;


	default:
		estado = 0;
		break;


	}

	return estado;
}

void MAX30102_Write( uint8_t reg, uint8_t value )
{
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Write(value);
	IIC_Stop();
}

uint8_t MAX30102_Read( uint8_t reg )
{
	uint8_t value;

	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	value = IIC_Read(NO_ACK);
	IIC_Stop();
	return value;
}

void MAX30102_Read_Sample( uint8_t reg, uint8_t * buff)
{
	uint8_t i;
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	for(i = 0; i < 6; i ++ )	//cada muestra es de 6 bytes
	{
		buff[i] = IIC_Read(ACK);
	}

	IIC_Stop();
}

void MAX30102_Read_FIFO( uint8_t reg, uint8_t * buff, uint8_t samples, uint32_t * red, uint32_t * ir)
{
	uint8_t i;
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS);
	IIC_Write(reg);
	IIC_Start();
	IIC_Write(MAX30102_PHY_ADDRESS | 1);
	if( samples )
	{	for(i = 0; i < samples*MAX30102_BYTES_PER_SAMPLE; i ++ )	//cada muestra es de 6 bytes
		{
			buff[i] = IIC_Read(ACK);
		}

	}
	else
	{
		for(i = 0; i < 6; i ++ )	//cada muestra es de 6 bytes
		{
			buff[i] = IIC_Read(ACK);
		}

	}
	IIC_Stop();

    // NOTA: ESTA FUNCIÓN SE LLAMA DESDE LA NUEVA LÓGICA
    // PERO LOS VALORES 'red' e 'ir' QUE CALCULA AQUÍ YA NO SE USAN
    // PARA EL BPM. EL PROCESAMIENTO SE HACE EN MAX30102().
	if( samples )
	{
		for(i = 0; i < samples; i ++ )
		{
			*red += (buff[(i*MAX30102_BYTES_PER_SAMPLE)]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+1]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+2];
			*ir += (buff[(i*MAX30102_BYTES_PER_SAMPLE)+3]<<16) | (buff[(i*MAX30102_BYTES_PER_SAMPLE)+4]<<8) | buff[(i*MAX30102_BYTES_PER_SAMPLE)+5];
		}
	}
	else
	{
		*red = (data[0]<<16) | (data[1]<<8) | data[2];
		*ir = (data[3]<<16) | (data[4]<<8) | data[5];
		*red &= 0x03FFFF;
		*ir &= 0x03FFFF;
	}

	if( samples )
	{
		*red /= samples;
		*ir /= samples;
		*red &= 0x03FFFF;
		*ir &= 0x03FFFF;
	}
}
